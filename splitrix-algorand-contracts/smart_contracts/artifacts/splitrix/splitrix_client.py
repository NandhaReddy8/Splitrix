# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "address", "name": "admin"}, {"type": "address[]", "name": "members"}], "name": "create_group", "returns": {"type": "uint64"}, "events": [{"args": [{"type": "uint64", "name": "group_id"}], "name": "GroupCreated"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "group_id"}, {"type": "address", "name": "payer"}, {"type": "uint64", "name": "total_amount"}, {"type": "(address,uint64)[]", "name": "debtors"}, {"type": "string", "name": "memo"}, {"type": "(uint64,address,uint64,uint64,uint64)[]", "name": "payers_debt"}], "name": "create_bill", "returns": {"type": "uint64"}, "events": [{"args": [{"type": "(uint64,uint64)", "name": "bill_key", "struct": "BillKey"}], "name": "BillChanged"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "group_id"}, {"type": "uint64", "name": "bill_id"}, {"type": "uint64", "name": "sender_index"}, {"type": "pay", "name": "payment"}], "name": "settle_bill", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}], "name": "Splitrix", "state": {"keys": {"box": {}, "global": {"group_counter": {"key": "Z3JvdXBfY291bnRlcg==", "keyType": "AVMString", "valueType": "AVMUint64"}}, "local": {}}, "maps": {"box": {"groups": {"keyType": "uint64", "valueType": "Group", "prefix": "Z3JvdXBz"}, "bills": {"keyType": "BillKey", "valueType": "Bill", "prefix": "YmlsbHM="}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 1}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"Bill": [{"name": "payer", "type": "address"}, {"name": "total_amount", "type": "uint64"}, {"name": "debtors", "type": "(address,uint64,uint64)[]"}, {"name": "memo", "type": "string"}], "BillKey": [{"name": "group_id", "type": "uint64"}, {"name": "bill_id", "type": "uint64"}], "Group": [{"name": "admin", "type": "address"}, {"name": "bill_counter", "type": "uint64"}, {"name": "members", "type": "address[]"}]}, "byteCode": {"approval": "CiAEAAEwICYGDWdyb3VwX2NvdW50ZXIIAAAAAAAAAAAFYmlsbHMEFR98dQZncm91cHMEd5QKuDEYQAADKCJnMRtBAHWCAwRxgAI1BCZ6Yv4Eq19qEzYaAI4DAEMAIQACIkMxGRREMRhENhoBNhoCNhoDMRYjCUk4ECMSRIgD7SNDMRkURDEYRDYaATYaAjYaAzYaBDYaBTYaBogA9CtMULAjQzEZFEQxGEQ2GgE2GgKIABErTFCwI0MxGUD/ojEYFEQjQ4oCASJJgABJIihlTElPAkQjCChMZ4ACAAGL/lCL/yJZIosHiwYMQQBwi/9XAgCLByULJVhJjAAyAxOLBYwBQQA+iwUiWYwCIowDiwOLAgxBAEOLBVcCAIsDJQslWIsAEkEAKSOLBYwBQAAUiwVXAgCLAFBJFSUKFlcGAkxQjAGLAYwFiwcjCIwHQv+ViwMjCIwDQv+1IkL/y4sFSSJZIw1Ei/4yAxNEi/4pUIACACpQTFCLBBYnBEsBUEm8SE8Cv4AEl0ru6ksBULCMAImKBgEiRwWAAEcEi/oXFicETFBHAr1FAUSL+zIDE0SL/CmlRIv9IllJTgJEi/4VRL5MSU8CRFcgCIACAAAiixCLDAxBALGL/VcCAIsQgSgLgShYSYwBVwAgSYwCMgMTiw+MA0EAVosPIlmMByKMBosGiwcMQQB8iw9XAgCLBiQLJFhXACCLAhJBAF8jiw+MA0AAKYsCi/sTQQAuiw9XAgCLAVcgCIsCTFApUFBJFSQKFlcGAkxQjA+LD4wDiwOMD4sQIwiMEEL/dYsPVwIAiwFXIAiLAksBUExQUEkVJAoWVwYCTFCMD0L/zosGIwiMBkL/fCJC/5WLDyJZSYwIRCKMCiKMEIsQiwgMQQAciw9XAgCLEElOAiQLJFglW4sKCIwKIwiMEEL/3IsKFov8qESL+osOUEmMBYv7i/xQgAIALFCLD0lOAhWBLAgWVwYCUExQi/5QKk8CUEmMAEm8SElPAr+LDUklWyMIFlwgiwtJvEhMv75MjAREi/8iWYwJIowQixCLCQxBAT+L/1cCAIsQSU4CgUALgUBYSVcACIv6TFAqSwFQSb1FAURJvkRJVwAgSwRXCCBMSwESREsEgShbSwKBKFlLA4EqWUsESwJLAlJJIllLBA1ESVcCAE8EJAtMSwEkWEsJJFtLASVbSwKBKFtMSwEJSwIPREsBCBZPAkxcKE8CgQIITwNMTwJdSwUiSwVYSwYVTwdLBU8CUkxLAlBMUE8DTwQJTwIVSwKBKlkITAkWVwYCXCpLA7xITwNMvycFTwNQsE8CgThbiwRJgShZSwGBKllLAksCSwJSSSJZSwUNRElXAgBPBSQLTEsBJFhJVwAgTwgSREmBKFtPBwhLASVbSwEPRBZcKEyBAghMXUsDIksEWEsEFU8FSwRPAlJMSwJQTFBPAk8DCU8CFUsCgSpZCEwJFlcGAlwqjAQjCIwQQv65iwBJvEiLBL8nBYsFULCLDowAiYoEAIv8i/1QKkxQRwK9RQFEvkxJTwJEi/84B0sBVwAgEkSL/hdLAYEoWUlOAk4DSwKBKllJTgRPA08DTwJSSU4CSSJZSwINRFcCAEwkC0lOAiRYRwJXACCL/zgAEkRJJVtMgShbSU4CCUcCRIv/OAhJTwINQQAEiwiMCYsHiwkIFosGTFwoiwWBAgiLBExPAl2LAUkiiwJJTgVYSwEVTwKLA0lOBE8CUkxLA1BMUExPAwlPAhVLAoEqWQhMCRZXBgJcKosASbxITL+J", "clear": "CoEBQw=="}, "events": [{"args": [{"type": "uint64", "name": "group_id"}], "name": "GroupCreated"}, {"args": [{"type": "(uint64,uint64)", "name": "bill_key", "struct": "BillKey"}], "name": "BillChanged"}], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMuc3BsaXRyaXguY29udHJhY3QuU3BsaXRyaXguX19hbGdvcHlfZW50cnlwb2ludF93aXRoX2luaXQoKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDQ4IDMyCiAgICBieXRlY2Jsb2NrICJncm91cF9jb3VudGVyIiAweDAwMDAwMDAwMDAwMDAwMDAgImJpbGxzIiAweDE1MWY3Yzc1ICJncm91cHMiIDB4Nzc5NDBhYjgKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo0NAogICAgLy8gc2VsZi5ncm91cF9jb3VudGVyLnZhbHVlID0gVUludDY0KDApCiAgICBieXRlY18wIC8vICJncm91cF9jb3VudGVyIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CgptYWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo0MAogICAgLy8gY2xhc3MgU3BsaXRyaXgoQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0A4CiAgICBwdXNoYnl0ZXNzIDB4NzE4MDAyMzUgMHgyNjdhNjJmZSAweGFiNWY2YTEzIC8vIG1ldGhvZCAiY3JlYXRlX2dyb3VwKGFkZHJlc3MsYWRkcmVzc1tdKXVpbnQ2NCIsIG1ldGhvZCAiY3JlYXRlX2JpbGwodWludDY0LGFkZHJlc3MsdWludDY0LChhZGRyZXNzLHVpbnQ2NClbXSxzdHJpbmcsKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KVtdKXVpbnQ2NCIsIG1ldGhvZCAic2V0dGxlX2JpbGwodWludDY0LHVpbnQ2NCx1aW50NjQscGF5KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2NyZWF0ZV9ncm91cF9yb3V0ZUA1IG1haW5fY3JlYXRlX2JpbGxfcm91dGVANiBtYWluX3NldHRsZV9iaWxsX3JvdXRlQDcKCm1haW5fYWZ0ZXJfaWZfZWxzZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo0MAogICAgLy8gY2xhc3MgU3BsaXRyaXgoQVJDNENvbnRyYWN0KToKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fc2V0dGxlX2JpbGxfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNjcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo0MAogICAgLy8gY2xhc3MgU3BsaXRyaXgoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE2NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0dGxlX2JpbGwKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX2JpbGxfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo3NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjQwCiAgICAvLyBjbGFzcyBTcGxpdHJpeChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5Ojc3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjcmVhdGVfYmlsbAogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfZ3JvdXBfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo1NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjQwCiAgICAvLyBjbGFzcyBTcGxpdHJpeChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjU1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjcmVhdGVfZ3JvdXAKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYmFyZV9yb3V0aW5nQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NDAKICAgIC8vIGNsYXNzIFNwbGl0cml4KEFSQzRDb250cmFjdCk6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDEwCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5zcGxpdHJpeC5jb250cmFjdC5TcGxpdHJpeC5jcmVhdGVfZ3JvdXAoYWRtaW46IGJ5dGVzLCBtZW1iZXJzOiBieXRlcykgLT4gYnl0ZXM6CmNyZWF0ZV9ncm91cDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo1NS01NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjcmVhdGVfZ3JvdXAoc2VsZiwgYWRtaW46IGFyYzQuQWRkcmVzcywgbWVtYmVyczogYXJjNC5EeW5hbWljQXJyYXlbYXJjNC5BZGRyZXNzXSkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byAyIDEKICAgIGludGNfMCAvLyAwCiAgICBkdXAKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NTcKICAgIC8vIGdyb3VwX2lkID0gc2VsZi5ncm91cF9jb3VudGVyLnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiZ3JvdXBfY291bnRlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ3JvdXBfY291bnRlciBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo1OAogICAgLy8gc2VsZi5ncm91cF9jb3VudGVyLnZhbHVlID0gZ3JvdXBfaWQgKyAxCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWNfMCAvLyAiZ3JvdXBfY291bnRlciIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NTkKICAgIC8vIG5ld19tZW1iZXJzID0gYXJjNC5EeW5hbWljQXJyYXlbYXJjNC5BZGRyZXNzXShhZG1pbikKICAgIHB1c2hieXRlcyAweDAwMDEKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NjAKICAgIC8vIGZvciBtIGluIG1lbWJlcnM6CiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18wIC8vIDAKCmNyZWF0ZV9ncm91cF9mb3JfaGVhZGVyQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NjAKICAgIC8vIGZvciBtIGluIG1lbWJlcnM6CiAgICBmcmFtZV9kaWcgNwogICAgZnJhbWVfZGlnIDYKICAgIDwKICAgIGJ6IGNyZWF0ZV9ncm91cF9hZnRlcl9mb3JANwogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDcKICAgIGludGNfMyAvLyAzMgogICAgKgogICAgaW50Y18zIC8vIDMyCiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NjEKICAgIC8vIGlmKG0ubmF0aXZlICE9IEdsb2JhbC56ZXJvX2FkZHJlc3MgYW5kIG5vdCBzZWxmLmNoZWNrX21lbWJlcl9leGlzdHMobmV3X21lbWJlcnMuY29weSgpLG0pKToKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9idXJ5IDEKICAgIGJ6IGNyZWF0ZV9ncm91cF9hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo1MAogICAgLy8gZm9yIG0gaW4gbWVtYmVyczoKICAgIGZyYW1lX2RpZyA1CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2J1cnkgMgogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMwoKY3JlYXRlX2dyb3VwX2Zvcl9oZWFkZXJAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo1MAogICAgLy8gZm9yIG0gaW4gbWVtYmVyczoKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgMgogICAgPAogICAgYnogY3JlYXRlX2dyb3VwX2FmdGVyX2ZvckAxMwogICAgZnJhbWVfZGlnIDUKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMwogICAgaW50Y18zIC8vIDMyCiAgICAqCiAgICBpbnRjXzMgLy8gMzIKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjUxCiAgICAvLyBpZiBtID09IG1lbWJlcjoKICAgIGZyYW1lX2RpZyAwCiAgICA9PQogICAgYnogY3JlYXRlX2dyb3VwX2FmdGVyX2lmX2Vsc2VAMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo1MgogICAgLy8gcmV0dXJuIFRydWUKICAgIGludGNfMSAvLyAxCgpjcmVhdGVfZ3JvdXBfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMuc3BsaXRyaXguY29udHJhY3QuU3BsaXRyaXguY2hlY2tfbWVtYmVyX2V4aXN0c0AxNDoKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo2MQogICAgLy8gaWYobS5uYXRpdmUgIT0gR2xvYmFsLnplcm9fYWRkcmVzcyBhbmQgbm90IHNlbGYuY2hlY2tfbWVtYmVyX2V4aXN0cyhuZXdfbWVtYmVycy5jb3B5KCksbSkpOgogICAgYm56IGNyZWF0ZV9ncm91cF9hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo2MgogICAgLy8gbmV3X21lbWJlcnMuYXBwZW5kKG0pCiAgICBmcmFtZV9kaWcgNQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAwCiAgICBjb25jYXQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMzIKICAgIC8KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMQoKY3JlYXRlX2dyb3VwX2FmdGVyX2lmX2Vsc2VANToKICAgIGZyYW1lX2RpZyAxCiAgICBmcmFtZV9idXJ5IDUKICAgIGZyYW1lX2RpZyA3CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA3CiAgICBiIGNyZWF0ZV9ncm91cF9mb3JfaGVhZGVyQDEKCmNyZWF0ZV9ncm91cF9hZnRlcl9pZl9lbHNlQDEyOgogICAgZnJhbWVfZGlnIDMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDMKICAgIGIgY3JlYXRlX2dyb3VwX2Zvcl9oZWFkZXJAOQoKY3JlYXRlX2dyb3VwX2FmdGVyX2ZvckAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo1MwogICAgLy8gcmV0dXJuIEZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjYxCiAgICAvLyBpZihtLm5hdGl2ZSAhPSBHbG9iYWwuemVyb19hZGRyZXNzIGFuZCBub3Qgc2VsZi5jaGVja19tZW1iZXJfZXhpc3RzKG5ld19tZW1iZXJzLmNvcHkoKSxtKSk6CiAgICBiIGNyZWF0ZV9ncm91cF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5zcGxpdHJpeC5jb250cmFjdC5TcGxpdHJpeC5jaGVja19tZW1iZXJfZXhpc3RzQDE0CgpjcmVhdGVfZ3JvdXBfYWZ0ZXJfZm9yQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NjMKICAgIC8vIGFzc2VydCBuZXdfbWVtYmVycy5sZW5ndGggPiAxLCAiQXQgbGVhc3QgdHdvIG1lbWJlcnMgbXVzdCBiZSBwcm92aWRlZCIKICAgIGZyYW1lX2RpZyA1CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18xIC8vIDEKICAgID4KICAgIGFzc2VydCAvLyBBdCBsZWFzdCB0d28gbWVtYmVycyBtdXN0IGJlIHByb3ZpZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NjQKICAgIC8vIGFzc2VydCBhZG1pbi5uYXRpdmUgIT0gR2xvYmFsLnplcm9fYWRkcmVzcywgIkFkbWluIG11c3QgYmUgcHJvdmlkZWQiCiAgICBmcmFtZV9kaWcgLTIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGFzc2VydCAvLyBBZG1pbiBtdXN0IGJlIHByb3ZpZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NjUKICAgIC8vIHNlbGYuZ3JvdXBzW2dyb3VwX2lkXSA9IEdyb3VwKGFkbWluPWFkbWluLGJpbGxfY291bnRlcj1hcmM0LlVJbnQ2NCgwKSxtZW1iZXJzPW5ld19tZW1iZXJzLmNvcHkoKSkKICAgIGZyYW1lX2RpZyAtMgogICAgYnl0ZWNfMSAvLyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4MDAyYQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyA0CiAgICBpdG9iCiAgICBieXRlYyA0IC8vICJncm91cHMiCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9kZWwKICAgIHBvcAogICAgdW5jb3ZlciAyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NjYKICAgIC8vIGFyYzQuZW1pdChHcm91cENyZWF0ZWQoZ3JvdXBfaWQ9YXJjNC5VSW50NjQoZ3JvdXBfaWQpKSkKICAgIHB1c2hieXRlcyAweDk3NGFlZWVhIC8vIG1ldGhvZCAiR3JvdXBDcmVhdGVkKHVpbnQ2NCkiCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo2NwogICAgLy8gcmV0dXJuIGFyYzQuVUludDY0KGdyb3VwX2lkKQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuc3BsaXRyaXguY29udHJhY3QuU3BsaXRyaXguY3JlYXRlX2JpbGwoZ3JvdXBfaWQ6IGJ5dGVzLCBwYXllcjogYnl0ZXMsIHRvdGFsX2Ftb3VudDogYnl0ZXMsIGRlYnRvcnM6IGJ5dGVzLCBtZW1vOiBieXRlcywgcGF5ZXJzX2RlYnQ6IGJ5dGVzKSAtPiBieXRlczoKY3JlYXRlX2JpbGw6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NzctODYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY3JlYXRlX2JpbGwoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBncm91cF9pZDogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgcGF5ZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICB0b3RhbF9hbW91bnQ6IGFyYzQuVUludDY0LAogICAgLy8gICAgIGRlYnRvcnM6IGFyYzQuRHluYW1pY0FycmF5W0RlYnRvck1pbmltYWxdLAogICAgLy8gICAgIG1lbW86IGFyYzQuU3RyaW5nLAogICAgLy8gICAgIHBheWVyc19kZWJ0OiBhcmM0LkR5bmFtaWNBcnJheVtQYXllckRlYnRdCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gNiAxCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA1CiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gNAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5Ojg3LTg4CiAgICAvLyAjIC0tLS0gVmFsaWRhdGlvbnMgLS0tLQogICAgLy8gYXNzZXJ0IGdyb3VwX2lkLm5hdGl2ZSBpbiBzZWxmLmdyb3VwcywgIkdyb3VwIGRvZXMgbm90IGV4aXN0IgogICAgZnJhbWVfZGlnIC02CiAgICBidG9pCiAgICBpdG9iCiAgICBieXRlYyA0IC8vICJncm91cHMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cG4gMgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gR3JvdXAgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo4OQogICAgLy8gYXNzZXJ0IHBheWVyLm5hdGl2ZSAhPSBHbG9iYWwuemVyb19hZGRyZXNzLCAiUGF5ZXIgbXVzdCBiZSBwcm92aWRlZCIKICAgIGZyYW1lX2RpZyAtNQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAhPQogICAgYXNzZXJ0IC8vIFBheWVyIG11c3QgYmUgcHJvdmlkZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo5MAogICAgLy8gYXNzZXJ0IHRvdGFsX2Ftb3VudCA+IDAsICJUb3RhbCBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCIKICAgIGZyYW1lX2RpZyAtNAogICAgYnl0ZWNfMSAvLyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIGI+CiAgICBhc3NlcnQgLy8gVG90YWwgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo5MQogICAgLy8gYXNzZXJ0IGRlYnRvcnMubGVuZ3RoID4gMCwgIkF0IGxlYXN0IG9uZSBkZWJ0b3IgbXVzdCBiZSBwcm92aWRlZCIKICAgIGZyYW1lX2RpZyAtMwogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBBdCBsZWFzdCBvbmUgZGVidG9yIG11c3QgYmUgcHJvdmlkZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo5MgogICAgLy8gYXNzZXJ0IG1lbW8uYnl0ZXMubGVuZ3RoID4gMCwgIk1lbW8gbXVzdCBiZSBwcm92aWRlZCIKICAgIGZyYW1lX2RpZyAtMgogICAgbGVuCiAgICBhc3NlcnQgLy8gTWVtbyBtdXN0IGJlIHByb3ZpZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6OTQKICAgIC8vIGdyb3VwID0gc2VsZi5ncm91cHNbZ3JvdXBfaWQubmF0aXZlXS5jb3B5KCkKICAgIGJveF9nZXQKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ncm91cHMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6OTUKICAgIC8vIGN1cnJlbnRfYmlsbF9pZCA9IGdyb3VwLmJpbGxfY291bnRlcgogICAgZXh0cmFjdCAzMiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5Ojk3LTk4CiAgICAvLyAjIC0tLS0gQnVpbGQgZGVidG9ycyBsaXN0IC0tLS0KICAgIC8vIGRlYnRvcnNfbmV3ID0gYXJjNC5EeW5hbWljQXJyYXlbRGVidG9yXSgpCiAgICBwdXNoYnl0ZXMgMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6OTkKICAgIC8vIGZvciBpIGluIHVyYW5nZShkZWJ0b3JzLmxlbmd0aCk6CiAgICBpbnRjXzAgLy8gMAoKY3JlYXRlX2JpbGxfZm9yX2hlYWRlckAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoZGVidG9ycy5sZW5ndGgpOgogICAgZnJhbWVfZGlnIDE2CiAgICBmcmFtZV9kaWcgMTIKICAgIDwKICAgIGJ6IGNyZWF0ZV9iaWxsX2FmdGVyX2ZvckAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjEwMAogICAgLy8gZCA9IGRlYnRvcnNbaV0uY29weSgpCiAgICBmcmFtZV9kaWcgLTMKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMTYKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgICoKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMDEKICAgIC8vIGlmIGQuZGVidG9yLm5hdGl2ZSAhPSBHbG9iYWwuemVyb19hZGRyZXNzIGFuZCBub3Qgc2VsZi5jaGVja19kZWJ0b3JfZXhpc3RzKGRlYnRvcnNfbmV3LmNvcHkoKSwgZC5kZWJ0b3IpOgogICAgZXh0cmFjdCAwIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGZyYW1lX2RpZyAxNQogICAgZnJhbWVfYnVyeSAzCiAgICBieiBjcmVhdGVfYmlsbF9hZnRlcl9pZl9lbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo3MQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKGRlYnRvcnMubGVuZ3RoKToKICAgIGZyYW1lX2RpZyAxNQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9idXJ5IDcKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDYKCmNyZWF0ZV9iaWxsX2Zvcl9oZWFkZXJAMjA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NzEKICAgIC8vIGZvciBpIGluIHVyYW5nZShkZWJ0b3JzLmxlbmd0aCk6CiAgICBmcmFtZV9kaWcgNgogICAgZnJhbWVfZGlnIDcKICAgIDwKICAgIGJ6IGNyZWF0ZV9iaWxsX2FmdGVyX2ZvckAyNAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjcyCiAgICAvLyBkID0gZGVidG9yc1tpXS5jb3B5KCkKICAgIGZyYW1lX2RpZyAxNQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyA2CiAgICBpbnRjXzIgLy8gNDgKICAgICoKICAgIGludGNfMiAvLyA0OAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6NzMKICAgIC8vIGlmIGQuZGVidG9yID09IGRlYnRvcjoKICAgIGV4dHJhY3QgMCAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyAyCiAgICA9PQogICAgYnogY3JlYXRlX2JpbGxfYWZ0ZXJfaWZfZWxzZUAyMwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5Ojc0CiAgICAvLyByZXR1cm4gVHJ1ZQogICAgaW50Y18xIC8vIDEKCmNyZWF0ZV9iaWxsX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnNwbGl0cml4LmNvbnRyYWN0LlNwbGl0cml4LmNoZWNrX2RlYnRvcl9leGlzdHNAMjU6CiAgICBmcmFtZV9kaWcgMTUKICAgIGZyYW1lX2J1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjEwMQogICAgLy8gaWYgZC5kZWJ0b3IubmF0aXZlICE9IEdsb2JhbC56ZXJvX2FkZHJlc3MgYW5kIG5vdCBzZWxmLmNoZWNrX2RlYnRvcl9leGlzdHMoZGVidG9yc19uZXcuY29weSgpLCBkLmRlYnRvcik6CiAgICBibnogY3JlYXRlX2JpbGxfYWZ0ZXJfaWZfZWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTAyCiAgICAvLyBpZiBkLmRlYnRvciAhPSBwYXllcjoKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9kaWcgLTUKICAgICE9CiAgICBieiBjcmVhdGVfYmlsbF9lbHNlX2JvZHlANgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gZGVidG9yc19uZXcuYXBwZW5kKERlYnRvcihkZWJ0b3I9ZC5kZWJ0b3IsIGFtb3VudD1kLmFtb3VudCwgcGFpZD1hcmM0LlVJbnQ2NCgwKSkpCiAgICBmcmFtZV9kaWcgMTUKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMQogICAgZXh0cmFjdCAzMiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMSAvLyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIGNvbmNhdAogICAgY29uY2F0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDQ4CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDE1CgpjcmVhdGVfYmlsbF9hZnRlcl9pZl9lbHNlQDc6CiAgICBmcmFtZV9kaWcgMTUKICAgIGZyYW1lX2J1cnkgMwoKY3JlYXRlX2JpbGxfYWZ0ZXJfaWZfZWxzZUA4OgogICAgZnJhbWVfZGlnIDMKICAgIGZyYW1lX2J1cnkgMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo5OQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKGRlYnRvcnMubGVuZ3RoKToKICAgIGZyYW1lX2RpZyAxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMTYKICAgIGIgY3JlYXRlX2JpbGxfZm9yX2hlYWRlckAxCgpjcmVhdGVfYmlsbF9lbHNlX2JvZHlANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMDUtMTA2CiAgICAvLyAjIHBheWVyJ3Mgb3duIHNoYXJlIGlzIGNvbnNpZGVyZWQgZnVsbHkgcGFpZAogICAgLy8gZGVidG9yc19uZXcuYXBwZW5kKERlYnRvcihkZWJ0b3I9ZC5kZWJ0b3IsIGFtb3VudD1kLmFtb3VudCwgcGFpZD1kLmFtb3VudCkpCiAgICBmcmFtZV9kaWcgMTUKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMQogICAgZXh0cmFjdCAzMiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIDIKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgY29uY2F0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDQ4CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDE1CiAgICBiIGNyZWF0ZV9iaWxsX2FmdGVyX2lmX2Vsc2VANwoKY3JlYXRlX2JpbGxfYWZ0ZXJfaWZfZWxzZUAyMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo3MQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKGRlYnRvcnMubGVuZ3RoKToKICAgIGZyYW1lX2RpZyA2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA2CiAgICBiIGNyZWF0ZV9iaWxsX2Zvcl9oZWFkZXJAMjAKCmNyZWF0ZV9iaWxsX2FmdGVyX2ZvckAyNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weTo3NQogICAgLy8gcmV0dXJuIEZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjEwMQogICAgLy8gaWYgZC5kZWJ0b3IubmF0aXZlICE9IEdsb2JhbC56ZXJvX2FkZHJlc3MgYW5kIG5vdCBzZWxmLmNoZWNrX2RlYnRvcl9leGlzdHMoZGVidG9yc19uZXcuY29weSgpLCBkLmRlYnRvcik6CiAgICBiIGNyZWF0ZV9iaWxsX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnNwbGl0cml4LmNvbnRyYWN0LlNwbGl0cml4LmNoZWNrX2RlYnRvcl9leGlzdHNAMjUKCmNyZWF0ZV9iaWxsX2FmdGVyX2ZvckAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMDgKICAgIC8vIGFzc2VydCBkZWJ0b3JzX25ldy5sZW5ndGggPiAwLCAiQXQgbGVhc3Qgb25lIHZhbGlkIGRlYnRvciBtdXN0IGJlIHByb3ZpZGVkIgogICAgZnJhbWVfZGlnIDE1CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgZnJhbWVfYnVyeSA4CiAgICBhc3NlcnQgLy8gQXQgbGVhc3Qgb25lIHZhbGlkIGRlYnRvciBtdXN0IGJlIHByb3ZpZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTEwLTExMQogICAgLy8gIyAtLS0tIENoZWNrIHRvdGFsIG1hdGNoZXMgLS0tLQogICAgLy8gdG90YWxfYW1vdW50X2NhbGN1bGF0ZWQgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTEyCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoZGVidG9yc19uZXcubGVuZ3RoKToKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDE2CgpjcmVhdGVfYmlsbF9mb3JfaGVhZGVyQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjExMgogICAgLy8gZm9yIGkgaW4gdXJhbmdlKGRlYnRvcnNfbmV3Lmxlbmd0aCk6CiAgICBmcmFtZV9kaWcgMTYKICAgIGZyYW1lX2RpZyA4CiAgICA8CiAgICBieiBjcmVhdGVfYmlsbF9hZnRlcl9mb3JAMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMTMKICAgIC8vIHggPSBkZWJ0b3JzX25ld1tpXS5jb3B5KCkKICAgIGZyYW1lX2RpZyAxNQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAxNgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzIgLy8gNDgKICAgICoKICAgIGludGNfMiAvLyA0OAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTE0CiAgICAvLyB0b3RhbF9hbW91bnRfY2FsY3VsYXRlZCA9IHRvdGFsX2Ftb3VudF9jYWxjdWxhdGVkICsgeC5hbW91bnQubmF0aXZlCiAgICBpbnRjXzMgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgMTAKICAgICsKICAgIGZyYW1lX2J1cnkgMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMTIKICAgIC8vIGZvciBpIGluIHVyYW5nZShkZWJ0b3JzX25ldy5sZW5ndGgpOgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMTYKICAgIGIgY3JlYXRlX2JpbGxfZm9yX2hlYWRlckAxMQoKY3JlYXRlX2JpbGxfYWZ0ZXJfZm9yQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjExNQogICAgLy8gYXNzZXJ0IHRvdGFsX2Ftb3VudF9jYWxjdWxhdGVkID09IHRvdGFsX2Ftb3VudCwgIlRvdGFsIGFtb3VudCBkb2VzIG5vdCBtYXRjaCB0aGUgc3VtIG9mIHRoZSBkZWJ0b3JzJyBhbW91bnRzIgogICAgZnJhbWVfZGlnIDEwCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTQKICAgIGI9PQogICAgYXNzZXJ0IC8vIFRvdGFsIGFtb3VudCBkb2VzIG5vdCBtYXRjaCB0aGUgc3VtIG9mIHRoZSBkZWJ0b3JzJyBhbW91bnRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTE3LTExOAogICAgLy8gIyAtLS0tIFNhdmUgbmV3IGJpbGwgLS0tLQogICAgLy8gbmV3X2JpbGxfa2V5ID0gQmlsbEtleShncm91cF9pZD1ncm91cF9pZCwgYmlsbF9pZD1jdXJyZW50X2JpbGxfaWQpCiAgICBmcmFtZV9kaWcgLTYKICAgIGZyYW1lX2RpZyAxNAogICAgY29uY2F0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgNQogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjExOS0xMjQKICAgIC8vIHNlbGYuYmlsbHNbbmV3X2JpbGxfa2V5XSA9IEJpbGwoCiAgICAvLyAgICAgcGF5ZXI9cGF5ZXIsCiAgICAvLyAgICAgdG90YWxfYW1vdW50PXRvdGFsX2Ftb3VudCwKICAgIC8vICAgICBkZWJ0b3JzPWRlYnRvcnNfbmV3LmNvcHkoKSwKICAgIC8vICAgICBtZW1vPW1lbW8KICAgIC8vICkKICAgIGZyYW1lX2RpZyAtNQogICAgZnJhbWVfZGlnIC00CiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDAwMmMKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDE1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgcHVzaGludCA0NCAvLyA0NAogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjExOQogICAgLy8gc2VsZi5iaWxsc1tuZXdfYmlsbF9rZXldID0gQmlsbCgKICAgIGJ5dGVjXzIgLy8gImJpbGxzIgogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTE5LTEyNAogICAgLy8gc2VsZi5iaWxsc1tuZXdfYmlsbF9rZXldID0gQmlsbCgKICAgIC8vICAgICBwYXllcj1wYXllciwKICAgIC8vICAgICB0b3RhbF9hbW91bnQ9dG90YWxfYW1vdW50LAogICAgLy8gICAgIGRlYnRvcnM9ZGVidG9yc19uZXcuY29weSgpLAogICAgLy8gICAgIG1lbW89bWVtbwogICAgLy8gKQogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTI1CiAgICAvLyBncm91cC5iaWxsX2NvdW50ZXIgPSBhcmM0LlVJbnQ2NChjdXJyZW50X2JpbGxfaWQubmF0aXZlICsgMSkKICAgIGZyYW1lX2RpZyAxMwogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6OTUKICAgIC8vIGN1cnJlbnRfYmlsbF9pZCA9IGdyb3VwLmJpbGxfY291bnRlcgogICAgaW50Y18zIC8vIDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTI1CiAgICAvLyBncm91cC5iaWxsX2NvdW50ZXIgPSBhcmM0LlVJbnQ2NChjdXJyZW50X2JpbGxfaWQubmF0aXZlICsgMSkKICAgIGV4dHJhY3RfdWludDY0CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgcmVwbGFjZTIgMzIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMjYKICAgIC8vIHNlbGYuZ3JvdXBzW2dyb3VwX2lkLm5hdGl2ZV0gPSBncm91cC5jb3B5KCkKICAgIGZyYW1lX2RpZyAxMQogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMjgtMTI5CiAgICAvLyAjIC0tLS0gUmVsb2FkIG5ldyBiaWxsIGludG8gbWVtb3J5IGZvciBuZXR0aW5nIHVwZGF0ZXMgLS0tLQogICAgLy8gbmV3X2JpbGwgPSBzZWxmLmJpbGxzW25ld19iaWxsX2tleV0uY29weSgpCiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJpbGxzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjEzMS0xMzIKICAgIC8vICMgLS0tLSBBcHBseSBuZXR0aW5nIC0tLS0KICAgIC8vIGZvciBpIGluIHVyYW5nZShwYXllcnNfZGVidC5sZW5ndGgpOgogICAgZnJhbWVfZGlnIC0xCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2J1cnkgOQogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMTYKCmNyZWF0ZV9iaWxsX2Zvcl9oZWFkZXJAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTMxLTEzMgogICAgLy8gIyAtLS0tIEFwcGx5IG5ldHRpbmcgLS0tLQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHBheWVyc19kZWJ0Lmxlbmd0aCk6CiAgICBmcmFtZV9kaWcgMTYKICAgIGZyYW1lX2RpZyA5CiAgICA8CiAgICBieiBjcmVhdGVfYmlsbF9hZnRlcl9mb3JAMTgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMzMKICAgIC8vIHBkID0gcGF5ZXJzX2RlYnRbaV0uY29weSgpCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMTYKICAgIGR1cAogICAgY292ZXIgMgogICAgcHVzaGludCA2NCAvLyA2NAogICAgKgogICAgcHVzaGludCA2NCAvLyA2NAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTM1LTEzNgogICAgLy8gIyBWYWxpZGF0ZSBhbmQgdXBkYXRlIG9sZCBiaWxsCiAgICAvLyBvbGRfYmlsbF9rZXkgPSBCaWxsS2V5KGdyb3VwX2lkPWdyb3VwX2lkLCBiaWxsX2lkPXBkLmJpbGxfaWQpCiAgICBkdXAKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC02CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMzcKICAgIC8vIGFzc2VydCBvbGRfYmlsbF9rZXkgaW4gc2VsZi5iaWxscywgIlJlZmVyZW5jZWQgYmlsbCBkb2VzIG5vdCBleGlzdCIKICAgIGJ5dGVjXzIgLy8gImJpbGxzIgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBSZWZlcmVuY2VkIGJpbGwgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMzgKICAgIC8vIG9sZF9iaWxsID0gc2VsZi5iaWxsc1tvbGRfYmlsbF9rZXldLmNvcHkoKQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5iaWxscyBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxMzkKICAgIC8vIGFzc2VydCBvbGRfYmlsbC5wYXllciA9PSBwZC5iaWxsX3BheWVyLCAiQmlsbCBwYXllciBtaXNtYXRjaCIKICAgIGR1cAogICAgZXh0cmFjdCAwIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZGlnIDQKICAgIGV4dHJhY3QgOCAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHN3YXAKICAgIGRpZyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIEJpbGwgcGF5ZXIgbWlzbWF0Y2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNDAKICAgIC8vIGFzc2VydCBwZC5wYXllcl9pbmRleF9pbl9iaWxsX2RlYnRvcnMubmF0aXZlIDwgb2xkX2JpbGwuZGVidG9ycy5sZW5ndGgsICJJbnZhbGlkIGRlYnRvciBpbmRleCIKICAgIGRpZyA0CiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDIKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMwogICAgcHVzaGludCA0MiAvLyA0MgogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyA0CiAgICBkaWcgMgogICAgZGlnIDIKICAgIHN1YnN0cmluZzMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgNAogICAgPgogICAgYXNzZXJ0IC8vIEludmFsaWQgZGVidG9yIGluZGV4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTQyCiAgICAvLyBvbGRfZGVidG9yID0gb2xkX2JpbGwuZGVidG9yc1twZC5wYXllcl9pbmRleF9pbl9iaWxsX2RlYnRvcnMubmF0aXZlXS5jb3B5KCkKICAgIGR1cAogICAgZXh0cmFjdCAyIDAKICAgIHVuY292ZXIgNAogICAgaW50Y18yIC8vIDQ4CiAgICAqCiAgICBzd2FwCiAgICBkaWcgMQogICAgaW50Y18yIC8vIDQ4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNDMKICAgIC8vIGN1dG9mZiA9IHBkLmFtb3VudF90b19jdXRvZmYubmF0aXZlCiAgICBkaWcgOQogICAgaW50Y18yIC8vIDQ4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE0NAogICAgLy8gYXNzZXJ0IGN1dG9mZiA8PSAob2xkX2RlYnRvci5hbW91bnQubmF0aXZlIC0gb2xkX2RlYnRvci5wYWlkLm5hdGl2ZSksICJDdXRvZmYgZXhjZWVkcyBwZW5kaW5nIGRlYnQiCiAgICBkaWcgMQogICAgaW50Y18zIC8vIDMyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDIKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBzd2FwCiAgICBkaWcgMQogICAgLQogICAgZGlnIDIKICAgID49CiAgICBhc3NlcnQgLy8gQ3V0b2ZmIGV4Y2VlZHMgcGVuZGluZyBkZWJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTQ2LTE0NwogICAgLy8gIyBNYXJrIGN1dG9mZiBhcyBwYWlkIGluIG9sZCBiaWxsCiAgICAvLyBvbGRfZGVidG9yLnBhaWQgPSBhcmM0LlVJbnQ2NChvbGRfZGVidG9yLnBhaWQubmF0aXZlICsgY3V0b2ZmKQogICAgZGlnIDEKICAgICsKICAgIGl0b2IKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgcmVwbGFjZTIgNDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNDgKICAgIC8vIG9sZF9iaWxsLmRlYnRvcnNbcGQucGF5ZXJfaW5kZXhfaW5fYmlsbF9kZWJ0b3JzLm5hdGl2ZV0gPSBvbGRfZGVidG9yLmNvcHkoKQogICAgdW5jb3ZlciAyCiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgdW5jb3ZlciAzCiAgICBzd2FwCiAgICB1bmNvdmVyIDIKICAgIHJlcGxhY2UzCiAgICBkaWcgNQogICAgaW50Y18wIC8vIDAKICAgIGRpZyA1CiAgICBleHRyYWN0MwogICAgZGlnIDYKICAgIGxlbgogICAgdW5jb3ZlciA3CiAgICBkaWcgNQogICAgdW5jb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBzd2FwCiAgICBkaWcgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICAtCiAgICB1bmNvdmVyIDIKICAgIGxlbgogICAgZGlnIDIKICAgIHB1c2hpbnQgNDIgLy8gNDIKICAgIGV4dHJhY3RfdWludDE2CiAgICArCiAgICBzd2FwCiAgICAtCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgNDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNDkKICAgIC8vIHNlbGYuYmlsbHNbb2xkX2JpbGxfa2V5XSA9IG9sZF9iaWxsLmNvcHkoKQogICAgZGlnIDMKICAgIGJveF9kZWwKICAgIHBvcAogICAgdW5jb3ZlciAzCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTUwCiAgICAvLyBhcmM0LmVtaXQoQmlsbENoYW5nZWQoYmlsbF9rZXk9b2xkX2JpbGxfa2V5KSkKICAgIGJ5dGVjIDUgLy8gbWV0aG9kICJCaWxsQ2hhbmdlZCgodWludDY0LHVpbnQ2NCkpIgogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE1Mi0xNTMKICAgIC8vICMgUmVmbGVjdCBjdXRvZmYgaW4gdGhlIG5ldyBiaWxsIChwYXllciBtdXN0IGV4aXN0IGluIG5ldyBiaWxsIGRlYnRvcnMpCiAgICAvLyBhc3NlcnQgcGQuZGVidG9yX2luZGV4X2luX2N1cnJlbnRfYmlsbC5uYXRpdmUgPCBuZXdfYmlsbC5kZWJ0b3JzLmxlbmd0aCwgIkludmFsaWQgZGVidG9yIGluZGV4IgogICAgdW5jb3ZlciAyCiAgICBwdXNoaW50IDU2IC8vIDU2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfZGlnIDQKICAgIGR1cAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAxCiAgICBwdXNoaW50IDQyIC8vIDQyCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDIKICAgIGRpZyAyCiAgICBkaWcgMgogICAgc3Vic3RyaW5nMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyA1CiAgICA+CiAgICBhc3NlcnQgLy8gSW52YWxpZCBkZWJ0b3IgaW5kZXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNTQKICAgIC8vIG5kID0gbmV3X2JpbGwuZGVidG9yc1twZC5kZWJ0b3JfaW5kZXhfaW5fY3VycmVudF9iaWxsLm5hdGl2ZV0uY29weSgpCiAgICBkdXAKICAgIGV4dHJhY3QgMiAwCiAgICB1bmNvdmVyIDUKICAgIGludGNfMiAvLyA0OAogICAgKgogICAgc3dhcAogICAgZGlnIDEKICAgIGludGNfMiAvLyA0OAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTU1CiAgICAvLyBhc3NlcnQgbmQuZGVidG9yID09IHBkLmJpbGxfcGF5ZXIsICJOZXcgYmlsbCBkb2VzIG5vdCBjb250YWluIHRoZSBwYXllciBmcm9tIG5ldHRpbmciCiAgICBkdXAKICAgIGV4dHJhY3QgMCAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHVuY292ZXIgOAogICAgPT0KICAgIGFzc2VydCAvLyBOZXcgYmlsbCBkb2VzIG5vdCBjb250YWluIHRoZSBwYXllciBmcm9tIG5ldHRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNTYKICAgIC8vIGFzc2VydCBuZC5wYWlkLm5hdGl2ZSArIGN1dG9mZiA8PSBuZC5hbW91bnQubmF0aXZlLCAiQ3V0b2ZmIGV4Y2VlZHMgbmV3IGJpbGwgb2JsaWdhdGlvbiIKICAgIGR1cAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgNwogICAgKwogICAgZGlnIDEKICAgIGludGNfMyAvLyAzMgogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAxCiAgICA+PQogICAgYXNzZXJ0IC8vIEN1dG9mZiBleGNlZWRzIG5ldyBiaWxsIG9ibGlnYXRpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNTcKICAgIC8vIG5kLnBhaWQgPSBhcmM0LlVJbnQ2NChuZC5wYWlkLm5hdGl2ZSArIGN1dG9mZikKICAgIGl0b2IKICAgIHJlcGxhY2UyIDQwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTU4CiAgICAvLyBuZXdfYmlsbC5kZWJ0b3JzW3BkLmRlYnRvcl9pbmRleF9pbl9jdXJyZW50X2JpbGwubmF0aXZlXSA9IG5kLmNvcHkoKQogICAgc3dhcAogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIHJlcGxhY2UzCiAgICBkaWcgMwogICAgaW50Y18wIC8vIDAKICAgIGRpZyA0CiAgICBleHRyYWN0MwogICAgZGlnIDQKICAgIGxlbgogICAgdW5jb3ZlciA1CiAgICBkaWcgNAogICAgdW5jb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBzd2FwCiAgICBkaWcgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgdW5jb3ZlciAzCiAgICAtCiAgICB1bmNvdmVyIDIKICAgIGxlbgogICAgZGlnIDIKICAgIHB1c2hpbnQgNDIgLy8gNDIKICAgIGV4dHJhY3RfdWludDE2CiAgICArCiAgICBzd2FwCiAgICAtCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgNDIKICAgIGZyYW1lX2J1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjEzMS0xMzIKICAgIC8vICMgLS0tLSBBcHBseSBuZXR0aW5nIC0tLS0KICAgIC8vIGZvciBpIGluIHVyYW5nZShwYXllcnNfZGVidC5sZW5ndGgpOgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMTYKICAgIGIgY3JlYXRlX2JpbGxfZm9yX2hlYWRlckAxNQoKY3JlYXRlX2JpbGxfYWZ0ZXJfZm9yQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE2MC0xNjEKICAgIC8vICMgLS0tLSBTYXZlIHRoZSB1cGRhdGVkIG5ldyBiaWxsIC0tLS0KICAgIC8vIHNlbGYuYmlsbHNbbmV3X2JpbGxfa2V5XSA9IG5ld19iaWxsLmNvcHkoKQogICAgZnJhbWVfZGlnIDAKICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICBmcmFtZV9kaWcgNAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE2MwogICAgLy8gYXJjNC5lbWl0KEJpbGxDaGFuZ2VkKGJpbGxfa2V5PW5ld19iaWxsX2tleSkpCiAgICBieXRlYyA1IC8vIG1ldGhvZCAiQmlsbENoYW5nZWQoKHVpbnQ2NCx1aW50NjQpKSIKICAgIGZyYW1lX2RpZyA1CiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE2NAogICAgLy8gcmV0dXJuIGN1cnJlbnRfYmlsbF9pZAogICAgZnJhbWVfZGlnIDE0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5zcGxpdHJpeC5jb250cmFjdC5TcGxpdHJpeC5zZXR0bGVfYmlsbChncm91cF9pZDogYnl0ZXMsIGJpbGxfaWQ6IGJ5dGVzLCBzZW5kZXJfaW5kZXg6IGJ5dGVzLCBwYXltZW50OiB1aW50NjQpIC0+IHZvaWQ6CnNldHRsZV9iaWxsOgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE2Ny0xNjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0dGxlX2JpbGwoc2VsZiwgZ3JvdXBfaWQ6IGFyYzQuVUludDY0LCBiaWxsX2lkOiBhcmM0LlVJbnQ2NCwgc2VuZGVyX2luZGV4OiBhcmM0LlVJbnQ2NCwgcGF5bWVudDogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24pIC0+IE5vbmU6CiAgICBwcm90byA0IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNjkKICAgIC8vIGJpbGxfa2V5ID0gQmlsbEtleShncm91cF9pZD1ncm91cF9pZCwgYmlsbF9pZD1iaWxsX2lkKQogICAgZnJhbWVfZGlnIC00CiAgICBmcmFtZV9kaWcgLTMKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE3MAogICAgLy8gYXNzZXJ0IGJpbGxfa2V5IGluIHNlbGYuYmlsbHMsICJCaWxsIGRvZXMgbm90IGV4aXN0IgogICAgYnl0ZWNfMiAvLyAiYmlsbHMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cG4gMgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQmlsbCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE3MQogICAgLy8gYmlsbCA9IHNlbGYuYmlsbHNbYmlsbF9rZXldLmNvcHkoKQogICAgYm94X2dldAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJpbGxzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE3MgogICAgLy8gYXNzZXJ0IHBheW1lbnQucmVjZWl2ZXIgPT0gYmlsbC5wYXllci5uYXRpdmUsICJQYXltZW50IG11c3QgYmUgc2VudCB0byB0aGUgcGF5ZXIiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBkaWcgMQogICAgZXh0cmFjdCAwIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgYmUgc2VudCB0byB0aGUgcGF5ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNzMKICAgIC8vIGFzc2VydCBzZW5kZXJfaW5kZXgubmF0aXZlIDwgYmlsbC5kZWJ0b3JzLmxlbmd0aCwgIlNlbmRlciBpbmRleCBpcyBvdXQgb2YgYm91bmRzIgogICAgZnJhbWVfZGlnIC0yCiAgICBidG9pCiAgICBkaWcgMQogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgZGlnIDIKICAgIHB1c2hpbnQgNDIgLy8gNDIKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIGR1cAogICAgY292ZXIgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAyCiAgICA+CiAgICBhc3NlcnQgLy8gU2VuZGVyIGluZGV4IGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxNzQKICAgIC8vIGRlYnRvciA9IGJpbGwuZGVidG9yc1tzZW5kZXJfaW5kZXgubmF0aXZlXS5jb3B5KCkKICAgIGV4dHJhY3QgMiAwCiAgICBzd2FwCiAgICBpbnRjXzIgLy8gNDgKICAgICoKICAgIGR1cAogICAgY292ZXIgMgogICAgaW50Y18yIC8vIDQ4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE3NQogICAgLy8gYXNzZXJ0IGRlYnRvci5kZWJ0b3IubmF0aXZlID09IHBheW1lbnQuc2VuZGVyLCAiU2VuZGVyIGlzIG5vdCBhIGRlYnRvciBmb3IgdGhpcyBiaWxsIgogICAgZXh0cmFjdCAwIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gU2VuZGVyIGlzIG5vdCBhIGRlYnRvciBmb3IgdGhpcyBiaWxsCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTc2CiAgICAvLyBhbW91bnRfdG9fcGF5ID0gZGVidG9yLmFtb3VudC5uYXRpdmUgLSBkZWJ0b3IucGFpZC5uYXRpdmUKICAgIGR1cAogICAgaW50Y18zIC8vIDMyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgc3dhcAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMgogICAgLQogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTc4CiAgICAvLyBhc3NlcnQgYW1vdW50X3RvX3BheSA+IDAsICJEZWJ0IGFscmVhZHkgcGFpZCIKICAgIGFzc2VydCAvLyBEZWJ0IGFscmVhZHkgcGFpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE4MQogICAgLy8gYW1vdW50X2FkZGVkID0gcGF5bWVudC5hbW91bnQKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE4MgogICAgLy8gaWYgYW1vdW50X2FkZGVkID4gYW1vdW50X3RvX3BheToKICAgID4KICAgIGJ6IHNldHRsZV9iaWxsX2FmdGVyX2lmX2Vsc2VAMgogICAgZnJhbWVfZGlnIDgKICAgIGZyYW1lX2J1cnkgOQoKc2V0dGxlX2JpbGxfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3NwbGl0cml4L2NvbnRyYWN0LnB5OjE4NQogICAgLy8gbmV3X2RlYnRvci5wYWlkID0gYXJjNC5VSW50NjQoZGVidG9yLnBhaWQubmF0aXZlICsgYW1vdW50X2FkZGVkKQogICAgZnJhbWVfZGlnIDcKICAgIGZyYW1lX2RpZyA5CiAgICArCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgNgogICAgc3dhcAogICAgcmVwbGFjZTIgNDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zcGxpdHJpeC9jb250cmFjdC5weToxODYKICAgIC8vIGJpbGwuZGVidG9yc1tzZW5kZXJfaW5kZXgubmF0aXZlXSA9IG5ld19kZWJ0b3IuY29weSgpCiAgICBmcmFtZV9kaWcgNQogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGZyYW1lX2RpZyA0CiAgICBzd2FwCiAgICB1bmNvdmVyIDIKICAgIHJlcGxhY2UzCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfZGlnIDIKICAgIGR1cAogICAgY292ZXIgNQogICAgZXh0cmFjdDMKICAgIGRpZyAxCiAgICBsZW4KICAgIHVuY292ZXIgMgogICAgZnJhbWVfZGlnIDMKICAgIGR1cAogICAgY292ZXIgNAogICAgdW5jb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBzd2FwCiAgICBkaWcgMwogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIHVuY292ZXIgMwogICAgLQogICAgdW5jb3ZlciAyCiAgICBsZW4KICAgIGRpZyAyCiAgICBwdXNoaW50IDQyIC8vIDQyCiAgICBleHRyYWN0X3VpbnQxNgogICAgKwogICAgc3dhcAogICAgLQogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDQyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3BsaXRyaXgvY29udHJhY3QucHk6MTg3CiAgICAvLyBzZWxmLmJpbGxzW2JpbGxfa2V5XSA9IGJpbGwuY29weSgpCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIHJldHN1Ygo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [362], "errorMessage": "Admin must be provided"}, {"pc": [443], "errorMessage": "At least one debtor must be provided"}, {"pc": [654], "errorMessage": "At least one valid debtor must be provided"}, {"pc": [356], "errorMessage": "At least two members must be provided"}, {"pc": [1148], "errorMessage": "Bill does not exist"}, {"pc": [843], "errorMessage": "Bill payer mismatch"}, {"pc": [1050], "errorMessage": "Cutoff exceeds new bill obligation"}, {"pc": [906], "errorMessage": "Cutoff exceeds pending debt"}, {"pc": [1239], "errorMessage": "Debt already paid"}, {"pc": [424], "errorMessage": "Group does not exist"}, {"pc": [247, 288, 454, 482, 486, 529, 530, 562, 608, 682, 809, 811, 831, 836, 885, 1027, 1029, 1161, 1214, 1217], "errorMessage": "Index access is out of bounds"}, {"pc": [872, 1014], "errorMessage": "Invalid debtor index"}, {"pc": [447], "errorMessage": "Memo must be provided"}, {"pc": [1035], "errorMessage": "New bill does not contain the payer from netting"}, {"pc": [101, 132, 166], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [430], "errorMessage": "Payer must be provided"}, {"pc": [1165], "errorMessage": "Payment must be sent to the payer"}, {"pc": [826], "errorMessage": "Referenced bill does not exist"}, {"pc": [1203], "errorMessage": "Sender index is out of bounds"}, {"pc": [1225], "errorMessage": "Sender is not a debtor for this bill"}, {"pc": [703], "errorMessage": "Total amount does not match the sum of the debtors' amounts"}, {"pc": [435], "errorMessage": "Total amount must be greater than 0"}, {"pc": [193], "errorMessage": "can only call when creating"}, {"pc": [104, 135, 169], "errorMessage": "can only call when not creating"}, {"pc": [776, 829, 1154], "errorMessage": "check self.bills entry exists"}, {"pc": [211], "errorMessage": "check self.group_counter exists"}, {"pc": [453], "errorMessage": "check self.groups entry exists"}, {"pc": [123], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class Bill:
    """Struct for Bill"""
    payer: str
    total_amount: int
    debtors: list[tuple[str, int, int]]
    memo: str

@dataclasses.dataclass(frozen=True)
class BillKey:
    """Struct for BillKey"""
    group_id: int
    bill_id: int

@dataclasses.dataclass(frozen=True)
class Group:
    """Struct for Group"""
    admin: str
    bill_counter: int
    members: list[str]


@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateGroupArgs:
    """Dataclass for create_group arguments"""
    admin: str
    members: list[str]

    @property
    def abi_method_signature(self) -> str:
        return "create_group(address,address[])uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateBillArgs:
    """Dataclass for create_bill arguments"""
    group_id: int
    payer: str
    total_amount: int
    debtors: list[tuple[str, int]]
    memo: str
    payers_debt: list[tuple[int, str, int, int, int]]

    @property
    def abi_method_signature(self) -> str:
        return "create_bill(uint64,address,uint64,(address,uint64)[],string,(uint64,address,uint64,uint64,uint64)[])uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class SettleBillArgs:
    """Dataclass for settle_bill arguments"""
    group_id: int
    bill_id: int
    sender_index: int
    payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "settle_bill(uint64,uint64,uint64,pay)void"


class SplitrixParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_group(
        self,
        args: tuple[str, list[str]] | CreateGroupArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_group(address,address[])uint64",
            "args": method_args,
        }))

    def create_bill(
        self,
        args: tuple[int, str, int, list[tuple[str, int]], str, list[tuple[int, str, int, int, int]]] | CreateBillArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_bill(uint64,address,uint64,(address,uint64)[],string,(uint64,address,uint64,uint64,uint64)[])uint64",
            "args": method_args,
        }))

    def settle_bill(
        self,
        args: tuple[int, int, int, algokit_utils.AppMethodCallTransactionArgument] | SettleBillArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "settle_bill(uint64,uint64,uint64,pay)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class SplitrixCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_group(
        self,
        args: tuple[str, list[str]] | CreateGroupArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_group(address,address[])uint64",
            "args": method_args,
        }))

    def create_bill(
        self,
        args: tuple[int, str, int, list[tuple[str, int]], str, list[tuple[int, str, int, int, int]]] | CreateBillArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_bill(uint64,address,uint64,(address,uint64)[],string,(uint64,address,uint64,uint64,uint64)[])uint64",
            "args": method_args,
        }))

    def settle_bill(
        self,
        args: tuple[int, int, int, algokit_utils.AppMethodCallTransactionArgument] | SettleBillArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "settle_bill(uint64,uint64,uint64,pay)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class SplitrixSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_group(
        self,
        args: tuple[str, list[str]] | CreateGroupArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_group(address,address[])uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def create_bill(
        self,
        args: tuple[int, str, int, list[tuple[str, int]], str, list[tuple[int, str, int, int, int]]] | CreateBillArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_bill(uint64,address,uint64,(address,uint64)[],string,(uint64,address,uint64,uint64,uint64)[])uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def settle_bill(
        self,
        args: tuple[int, int, int, algokit_utils.AppMethodCallTransactionArgument] | SettleBillArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "settle_bill(uint64,uint64,uint64,pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    group_counter: int

class SplitrixState:
    """Methods to access state for the current Splitrix app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def group_counter(self) -> int:
        """Get the current value of the group_counter key in global_state state"""
        value = self.app_client.state.global_state.get_value("group_counter")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {
            "Group": Group,
            "Bill": Bill
        }

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def groups(self) -> "_MapState[int, Group]":
        """Get values from the groups map in box state"""
        return _MapState(
            self.app_client.state.box,
            "groups",
            self._struct_classes.get("Group")
        )

    @property
    def bills(self) -> "_MapState[BillKey, Bill]":
        """Get values from the bills map in box state"""
        return _MapState(
            self.app_client.state.box,
            "bills",
            self._struct_classes.get("Bill")
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class SplitrixClient:
    """Client for interacting with Splitrix smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = SplitrixParams(self.app_client)
        self.create_transaction = SplitrixCreateTransactionParams(self.app_client)
        self.send = SplitrixSend(self.app_client)
        self.state = SplitrixState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "SplitrixClient":
        return SplitrixClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "SplitrixClient":
        return SplitrixClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "SplitrixClient":
        return SplitrixClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "SplitrixComposer":
        return SplitrixComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_group(address,address[])uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_bill(uint64,address,uint64,(address,uint64)[],string,(uint64,address,uint64,uint64,uint64)[])uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["settle_bill(uint64,uint64,uint64,pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | int:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class SplitrixBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating Splitrix contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class SplitrixFactory(algokit_utils.TypedAppFactoryProtocol[SplitrixBareCallCreateParams, None, None]):
    """Factory for deploying and managing SplitrixClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = SplitrixFactoryParams(self.app_factory)
        self.create_transaction = SplitrixFactoryCreateTransaction(self.app_factory)
        self.send = SplitrixFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: SplitrixBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[SplitrixClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return SplitrixClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> SplitrixClient:
        """Get an app client by creator address and name"""
        return SplitrixClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> SplitrixClient:
        """Get an app client by app ID"""
        return SplitrixClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class SplitrixFactoryParams:
    """Parameters for creating transactions for Splitrix contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = SplitrixFactoryCreateParams(app_factory)
        self.update = SplitrixFactoryUpdateParams(app_factory)
        self.delete = SplitrixFactoryDeleteParams(app_factory)

class SplitrixFactoryCreateParams:
    """Parameters for 'create' operations of Splitrix contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def create_group(
        self,
        args: tuple[str, list[str]] | CreateGroupArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_group(address,address[])uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_group(address,address[])uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def create_bill(
        self,
        args: tuple[int, str, int, list[tuple[str, int]], str, list[tuple[int, str, int, int, int]]] | CreateBillArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_bill(uint64,address,uint64,(address,uint64)[],string,(uint64,address,uint64,uint64,uint64)[])uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_bill(uint64,address,uint64,(address,uint64)[],string,(uint64,address,uint64,uint64,uint64)[])uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def settle_bill(
        self,
        args: tuple[int, int, int, algokit_utils.AppMethodCallTransactionArgument] | SettleBillArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the settle_bill(uint64,uint64,uint64,pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "settle_bill(uint64,uint64,uint64,pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class SplitrixFactoryUpdateParams:
    """Parameters for 'update' operations of Splitrix contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class SplitrixFactoryDeleteParams:
    """Parameters for 'delete' operations of Splitrix contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class SplitrixFactoryCreateTransaction:
    """Create transactions for Splitrix contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = SplitrixFactoryCreateTransactionCreate(app_factory)


class SplitrixFactoryCreateTransactionCreate:
    """Create new instances of Splitrix contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class SplitrixFactorySend:
    """Send calls to Splitrix contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = SplitrixFactorySendCreate(app_factory)


class SplitrixFactorySendCreate:
    """Send create calls to Splitrix contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[SplitrixClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return SplitrixClient(result[0]), result[1]


class SplitrixComposer:
    """Composer for creating transaction groups for Splitrix contract calls"""

    def __init__(self, client: "SplitrixClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def create_group(
        self,
        args: tuple[str, list[str]] | CreateGroupArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "SplitrixComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_group(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_group(address,address[])uint64", v
            )
        )
        return self

    def create_bill(
        self,
        args: tuple[int, str, int, list[tuple[str, int]], str, list[tuple[int, str, int, int, int]]] | CreateBillArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "SplitrixComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_bill(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_bill(uint64,address,uint64,(address,uint64)[],string,(uint64,address,uint64,uint64,uint64)[])uint64", v
            )
        )
        return self

    def settle_bill(
        self,
        args: tuple[int, int, int, algokit_utils.AppMethodCallTransactionArgument] | SettleBillArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "SplitrixComposer":
        self._composer.add_app_call_method_call(
            self.client.params.settle_bill(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "settle_bill(uint64,uint64,uint64,pay)void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "SplitrixComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "SplitrixComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
